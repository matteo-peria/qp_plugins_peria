!module io_array
module io_z

  use io_color
  use io_const

  implicit none

  real(dp) :: threshold_default = 1.e-6

contains


subroutine compute_dp_array_diff(arr1, arr2, threshold, show, row_indx, col_indx)
  implicit none
  real(dp), intent(in) :: arr1(:,:)
  real(dp), intent(in) :: arr2(:,:)
  real(dp), intent(in), optional :: threshold
  logical,  intent(in), optional :: show
  integer,  intent(in), optional :: row_indx(:)
  integer,  intent(in), optional :: col_indx(:)
  ! Manage optional arguments
  real(dp)             :: thr
  logical              :: show_array
  integer, allocatable :: r_indx(:)
  integer, allocatable :: c_indx(:)
 
  real(dp) :: difference
  logical, allocatable :: mask(:,:)
  integer :: row, col

  ! Check arguments
  if (any(shape(arr1) /= shape(arr2))) then
    print *, "❌ Arrays have different shapes."
    return
  end if

  ! Manage optional arguments
  if (present(threshold)) then 
    thr = threshold  
  else
    thr = threshold_default
  end if

  if (present(show)) then 
    show_array = show
  else
    show_array = .True.
  end if

  if (present(row_indx)) then 
    r_indx = row_indx
  else
    r_indx = [(row, row=1,size(arr1,1))]
  end if

  if (present(col_indx)) then 
    c_indx = col_indx
  else
    c_indx = [(col, col=1,size(arr1,2))]
  end if

  difference = sum(abs(arr1(row_indx,col_indx) - arr2(row_indx,col_indx)))
  print*,'Difference = ', difference

  if (show_array) then
    mask = (abs(arr1(r_indx,c_indx) - arr2(r_indx,c_indx)) <= thr)
    call print_array_color(arr1(r_indx,c_indx), mask)
  end if
end subroutine compute_dp_array_diff


subroutine print_array_color(arr, mask)
  implicit none

  real(dp), intent(in) :: arr(:,:)
  logical,  intent(in) :: mask(:,:)

  integer :: row, col
  character(len=:), allocatable :: esc_green, esc_red, esc_reset

  esc_green = escape_color(color%green)
  esc_red   = escape_color(color%red)
  esc_reset = escape_color(color%reset)

  if (any(shape(arr) /= shape(mask))) then
    print *, "❌ Array and coloring mask have different shapes."
    return
  end if

  do row = 1, size(arr, 1)
    do col = 1, size(arr, 2)
      if (mask(row,col)) then
        write(*,'(A,F12.7,A)', advance="no") esc_green, arr(row,col), esc_reset
      else
        write(*,'(A,F12.7,A)', advance="no") esc_red, arr(row,col), esc_reset
      end if
    end do
    print*  ! newline
  end do

  print*  ! extra space after matrix 
end subroutine print_array_color




subroutine print_array_diff(arr1, arr2, threshold)
  implicit none

  real(dp), intent(in) :: arr1(:,:), arr2(:,:)
  real(dp), intent(in) :: threshold

  integer :: row, col
  character(len=:), allocatable :: esc_green, esc_red, esc_reset
  real(dp) :: val1, val2

  esc_green = escape_color(color%green)
  esc_red   = escape_color(color%red)
  esc_reset = escape_color(color%reset)

  if (any(shape(arr1) /= shape(arr2))) then
    print *, "❌ Arrays have different shapes."
    return
  end if

  do row = 1, size(arr1, 1)
    do col = 1, size(arr1, 2)
      val1 = arr1(row, col)
      val2 = arr2(row, col)

      if (abs(val1 - val2) <= threshold) then
        write(*,'(A,F12.7,A)', advance="no") esc_green, val1, esc_reset
      else
        write(*,'(A,F12.7,A)', advance="no") esc_red, val1, esc_reset
      end if
    end do
    print*  ! newline
  end do

  print*  ! extra space after matrix 
end subroutine print_array_diff


subroutine print_db_array(array,indx_row,indx_col)
  implicit none
  double precision, intent(in) :: array(:,:)
  integer, intent(in) :: indx_row(:)
  integer, intent(in) :: indx_col(:)
  !
  integer :: row, col
  integer :: val_indx

  do row = 1, size(indx_row)
    write(*,'(100F13.4)') (array(indx_row(row), indx_col(col)), col=1,size(indx_col))
  end do

end subroutine print_db_array


end module io_z
